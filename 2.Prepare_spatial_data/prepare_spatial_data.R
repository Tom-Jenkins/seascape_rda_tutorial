# --------------------------- #
#
# Tutorial:
# Seascape Redundancy Analysis
# 
# Description:
# Prepare spatial data for redundancy analysis.
#
# Data:
# European lobster SNP genotypes generated by a Fluidigm EP1 system.
# Tutorial uses 37 sites from the original study (Jenkins et al. 2019).
# https://doi.org/10.1111/eva.12849.
#
# Notes before execution:
# 1. Make sure all required R packages are installed.
# 2. Set working directory to the location of this R script.
#
# --------------------------- #

# Load packages
library(marmap)
library(tidyverse)
library(ade4)
library(adespatial)
library(SoDA)
library(psych)


#--------------#
#
# Calculate least-cost distances across seas
#
#--------------#

# Get bathymetry data from NOAA using marmap package
bathydata = getNOAA.bathy(lon1 = -15,
                          lon2 = 30,
                          lat1 = 35,
                          lat2 = 65,
                          resolution = 2)

# Import coordinates of sites
coords = read.csv("coordinates.csv")
head(coords)
coords.gps = dplyr::select(coords, Lon, Lat)

# Get depth of coordinates
depths = get.depth(bathydata, x = coords$Lon, y = coords$Lat, locator = FALSE)
depths

# Check all coordinates are below 1 metre depth
depths$depth <= -1

# Plot bathymetry data and coordinates
plot(bathydata)
points(coords$Lon, coords$Lat, pch = 21, bg = "yellow", col = "black")

# Create transition object [long run time]
# trans1 = trans.mat(bathydata, min.depth = -1, max.depth = NULL)
# save(trans1, file = "transition_object.RData")
# load("transition_object.RData")

# Compute least-cost paths [long run time]
# lc_paths = lc.dist(trans1, coords.gps, res = "path")
# save(lc_paths, file = "least_cost_paths.RData")
load("least_cost_paths.RData")

# Plot paths on a map
# Visually check that no path overlaps land
plot.bathy(bathydata, image= TRUE, land = TRUE, n = 0,
           bpal = list(c(0, max(bathydata), "grey"),
                       c(min(bathydata), 0, "royalblue")))
lapply(lc_paths, lines, col = "orange", lwd = 2, lty = 1)

# Compute least-cost distances (km) matrix
lc_dist = lc.dist(trans1, coords.gps, res = "dist")

# Convert to matrix, rename columns and rows, and export as csv file
lc_mat = as.matrix(lc_dist)
colnames(lc_mat) = as.vector(coords$Site)
rownames(lc_mat) = as.vector(coords$Site)
lc_mat
# write.csv(lc_mat, file="lc_distances_km.csv")


#--------------#
#
# Compute dbMEMs
#
#--------------#

# Further info on distance-based Moran's Eigenvector Maps in the vignette
# vignette("tutorial", package = "adespatial")

# Transform geographic coordinates into cartesian coordinates
# Calculate euclidian distances (km)
# cart = geoXY(coords$Lat, coords$Lon, unit = 1000)
# euclidian_distances = dist(cart, method = "euclidean") 

# Compute distance-based Moran's Eigenvector Maps
dbmems = dbmem(lc_dist, MEM.autocor = "non-null")
dbmems

# Export dbMEMs
write.csv(dbmems, file = "dbmems.csv", row.names = FALSE)
